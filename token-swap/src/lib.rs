extern crate spl_token;

use num_derive::FromPrimitive;
use num_traits::FromPrimitive;
use solana_sdk::program::invoke_signed;
use solana_sdk::{
    account_info::AccountInfo, entrypoint::ProgramResult, info, program_error::ProgramError,
    program_utils::next_account_info, pubkey::Pubkey,
};
use std::mem::size_of;
use thiserror::Error;

/// Instructions supported by the token program.
#[repr(C)]
#[derive(Clone, Debug, PartialEq)]
pub enum Instruction {
    /// Initalizes a new TokenSwap.
    ///
    /// TokenSwap uses $instance as the authority.  $instance is the address generated by
    /// `create_program_address(&[TokenSwap Account], program_id)`.  Token accounts
    /// cannot have 0 in the account and must have 0 delegations and owned by $instance. The pool Mint
    /// account must have 0 supply owned by the $instance_id.
    ///
    /// # Accounts expected by this instruction:
    ///
    ///   0. `[writable, signer]` New Token-swap to create.
    ///   1. `[]` $instance
    ///   2. `[]` base_token_a Account
    ///   3. `[]` base_token_b Account
    ///   4. `[writable]` pool_mint Account.
    ///   5. `[writable]` Pool Account to deposit the generated tokens, user is the owner.
    Init,

    ///   Deposit some tokens into the pool.  The output is a "pool" token representing ownership
    ///   into the pool. Inputs are converted to the current ratio.
    ///
    ///   0. `[]` Token-swap instance
    ///   1. `[]` $instance
    ///   2. `[writable]` token_(A|B) SOURCE Account assigned to $instance as the owner.
    ///   3. `[writable]` token_(A|B) Base Account to deposit into.  Must be SOURCE token.
    ///   4. `[writable]` Pool MINT account, $instance is the owner.
    ///   4. `[writable]` Pool Account to deposit the generated tokens, user is the owner.
    Deposit,

    ///   Withdraw the token from the pool at the current ratio.
    ///   
    ///   0. `[]` Token-swap
    ///   1. `[]` $instance
    ///   2. `[writable]` SOURCE Pool Account, $instance is the owner, amount is total to burn.
    ///   3. `[writable]` Pool MINT account, $instance is the owner.
    ///   4. `[writable]` token_(A|B) Base Account to withdraw FROM.
    ///   5. `[writable]` token_(A|B) DEST Account assigned to USER as the owner.
    Withdraw,

    ///   Swap the tokens in the pool.
    ///
    ///   0. `[]` Token-swap
    ///   1. `[]` $instance
    ///   2. `[writable]` token_(A|B) SOURCE Account assigned to $instance as the owner.
    ///   3. `[writable]` token_(A|B) Base Account to swap INTO.  Must be the SOURCE token.
    ///   4. `[writable]` token_(A|B) Base Account to swap FROM.  Must be the DEST token.
    ///   5. `[writable]` token_(A|B) DEST Account assigned to USER as the owner.
    Swap,
}

#[derive(Clone, Debug, Eq, Error, FromPrimitive, PartialEq)]
pub enum Error {
    /// The account cannot be initialized because it is already being used.
    #[error("AlreadyInUse")]
    AlreadyInUse,

    /// The program address provided doesn't match the value generated by the program.
    #[error("InvalidProgramAddress")]
    InvalidProgramAddress,

    /// The owner of the input isn't set to the program address generated by the program.
    #[error("InvalidOwner")]
    InvalidOwner,

    /// The deserialization of the Token state returned something besides State::Token
    #[error("ExpectedToken")]
    ExpectedToken,

    /// The deserialization of the Token state returned something besides State::Account
    #[error("ExpectedAccount")]
    ExpectedAccount,

    /// The intiailized pool had a non zero supply
    #[error("InvalidSupply")]
    InvalidSupply,

    /// The intiailized token has a delegate
    #[error("InvalidDelegate")]
    InvalidDelegate,
}

impl From<Error> for ProgramError {
    fn from(e: Error) -> Self {
        ProgramError::Custom(e as u32)
    }
}

#[repr(C)]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
pub struct TokenSwap {
    /// token A
    /// The Liqudity token is issued against this value.
    token_a: Pubkey,
    /// token B
    token_b: Pubkey,
    /// pool tokens are issued when A or B tokens are deposited
    /// pool tokens can be withdrawn back to the original A or B token
    pool_mint: Pubkey,
    /// fee applied to the input token amount prior to output calculation
    fee: (u64, u64),
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum State {
    /// Unallocated state, may be initialized into another state.
    Unallocated,
    Init(TokenSwap),
}

struct Invariant {
    token_a: u64,
    token_b: u64,
}

impl Invariant {
    fn swap(&mut self, token_a: u64) -> Option<u64> {
        let invariant = self.token_a.checked_mul(self.token_b)?;
        let new_a = self.token_a.checked_add(token_a)?;
        let new_b = invariant.checked_div(new_a)?;
        let remove = self.token_b.checked_sub(new_b)?;
        self.token_a = new_a;
        self.token_b = new_b;
        Some(remove)
    }
}

impl<'a> State {
    pub fn to_str(key: &Pubkey) -> &str {
        unimplemented!();
    }
    pub fn deserialize(input: &'a [u8]) -> Result<Self, ProgramError> {
        if input.len() < size_of::<u8>() {
            return Err(ProgramError::InvalidAccountData);
        }
        Ok(match input[0] {
            0 => Self::Unallocated,
            1 => {
                if input.len() < size_of::<u8>() + size_of::<TokenSwap>() {
                    return Err(ProgramError::InvalidAccountData);
                }
                #[allow(clippy::cast_ptr_alignment)]
                let swap: &TokenSwap = unsafe { &*(&input[1] as *const u8 as *const TokenSwap) };
                Self::Init(*swap)
            }
            _ => return Err(ProgramError::InvalidAccountData),
        })
    }

    pub fn serialize(self: &Self, output: &mut [u8]) -> ProgramResult {
        if output.len() < size_of::<u8>() {
            return Err(ProgramError::InvalidAccountData);
        }
        match self {
            Self::Unallocated => output[0] = 0,
            Self::Init(swap) => {
                if output.len() < size_of::<u8>() + size_of::<TokenSwap>() {
                    return Err(ProgramError::InvalidAccountData);
                }
                output[0] = 1;
                #[allow(clippy::cast_ptr_alignment)]
                let value = unsafe { &mut *(&mut output[1] as *mut u8 as *mut TokenSwap) };
                *value = *swap;
            }
        }
        Ok(())
    }

    pub fn token_instruction(
        owner: &Pubkey,
        accounts: &[(Pubkey, bool, bool)],
        userdata: &[u8],
    ) -> solana_sdk::instruction::Instruction {
        unimplemented!();
    }

    pub fn token_account_deserialize(
        info: &AccountInfo,
    ) -> Result<spl_token::state::Account, Error> {
        if let Some(spl_token::state::State::Account(account)) =
            spl_token::state::State::deserialize(&info.data.borrow()).ok()
        {
            Ok(account)
        } else {
            Err(Error::ExpectedAccount)
        }
    }

    pub fn token_deserialize(info: &AccountInfo) -> Result<spl_token::state::Token, Error> {
        if let Some(spl_token::state::State::Token(token)) =
            spl_token::state::State::deserialize(&info.data.borrow()).ok()
        {
            Ok(token)
        } else {
            Err(Error::ExpectedToken)
        }
    }

    pub fn instance_id(program_id: &Pubkey, my_info: &AccountInfo) -> Result<Pubkey, Error> {
        Pubkey::create_program_address(&[Self::to_str(my_info.key)], program_id).or(Err(Error::InvalidProgramAddress))
    }

    pub fn token_issue(authority: &AccountInfo, token: &AccountInfo, destination: &AccountInfo, amount: u64) -> Result<Pubkey, Error> {
        unimplemented!();
    }

    pub fn process_init<I: Iterator<Item = &'a AccountInfo<'a>>>(
        program_id: &Pubkey,
        account_info_iter: &mut I,
    ) -> ProgramResult {
        let token_swap_info = next_account_info(account_info_iter)?;
        let instance_id_info = next_account_info(account_info_iter)?;
        let base_token_a = next_account_info(account_info_iter)?;
        let base_token_b = next_account_info(account_info_iter)?;
        let pool_mint_info = next_account_info(account_info_iter)?;
        let user_pool_output = next_account_info(account_info_iter)?;

        if State::Unallocated != State::deserialize(&token_swap_info.data.borrow())? {
            return Err(Error::AlreadyInUse.into());
        }

        if *instance_id_info.key != Self::instance_id(program_id, token_swap_info)?
        {
            return Err(Error::InvalidProgramAddress.into());
        }
        let token_a = Self::token_account_deserialize(base_token_a)?;
        let token_b = Self::token_account_deserialize(base_token_b)?;
        let pool_mint = Self::token_deserialize(pool_mint_info)?;
        if *instance_id_info.key != token_a.owner {
            return Err(Error::InvalidOwner.into());
        }
        if *instance_id_info.key != token_b.owner {
            return Err(Error::InvalidOwner.into());
        }
        if Some(*instance_id_info.key) != pool_mint.owner {
            return Err(Error::InvalidOwner.into());
        }
        if 0 != pool_mint.info.supply {
            return Err(Error::InvalidSupply.into());
        }
        if token_b.amount == 0 {
            return Err(Error::InvalidSupply.into());
        }
        if token_a.amount == 0 {
            return Err(Error::InvalidSupply.into());
        }
        if token_a.delegate.is_some() {
            return Err(Error::InvalidDelegate.into());
        }
        if token_b.delegate.is_some() {
            return Err(Error::InvalidDelegate.into());
        }
        // liquidity token is 2x the A token amount
        // because the token_b amount has the same value at the current ratio
        let amount = token_a.amount * 2;
        Self::token_issue(instance_id_info, pool_mint_info, user_pool_output, amount)?;

        let obj = State::Init(TokenSwap {
            token_a: *base_token_a.key,
            token_b: *base_token_b.key,
            pool_mint: *pool_mint_info.key,
            fee: (0, 0),
        });
        obj.serialize(&mut token_swap_info.data.borrow_mut())
    }

    //     pub fn transfer_token(
    //         instance_id: &Pubkey,
    //         source: &Pubkey,
    //         destination: &Pubkey,
    //         amount: u64,
    //     ) -> ProgramResult {
    //         let signers = &[&[instance_id, "authority"]],
    //         let authority = Pubkey::create_program_address(&[instance_id, "authority"], program_id)?;
    //         let source = Pubkey::create_program_address(&[instance_id, kind], program_id)?;
    //         let instruction_data = vec![];
    //         let instruction = token::Instruction::Transfer(amount);
    //         instruction.serialize(&mut instruction_data)?;
    //         let invoked_instruction = create_instruction(
    //             token_account.owner,
    //             &[
    //                 (authority, false, true),
    //                 (source, true, false),
    //                 (destination, true, false),
    //             ],
    //             instruction_data,
    //         );
    //         invoke_signed(
    //             &invoked_instruction,
    //             accounts,
    //             signers,
    //         )
    //     }
    //     pub fn process_swap<I: Iterator<Item = &'a AccountInfo<'a>>>(
    //         program_id: &Pubkey,
    //         account_info_iter: &mut I,
    //     ) -> ProgramResult {
    //         let token_swap_account = next_account_info(account_info_iter)?;
    //         let state = State::deserialize(&token_swap_account.data.borrow())?;
    //         let swap = state.swap()?;
    //
    //         let authority = next_account_info(account_info_iter)?;
    //         if !authority.is_signer {
    //             return Err(ProgramError::MissingRequiredSignature);
    //         }
    //         if !authority.pubkey != swap.authority {
    //             return Err(ProgramError::InvalidAuthority);
    //         }
    //         let instance_id = token_swap_account.key;
    //         let token_authority = Pubkey::create_program_address(&[instance_id, "authority"], program_id)?;
    //
    //         let tokenA_account = Pubkey::create_program_address(&[instance_id, "tokenA"], program_id)?;
    //
    //         //tokenA
    //         let tokenA_info = next_account_info(account_info_iter)?;
    //         if tokenA_info.key != tokenA_account {
    //             return Err(Error::InvalidTokenAAccount);
    //         }
    //         let tokenA_account = token::Account::deserialize(tokenA_info.data)?;
    //
    //         let tokenB_account = Pubkey::create_program_address(&[instance_id, "tokenB"], program_id)?;
    //
    //         //tokenB
    //         let tokenB_info = next_account_info(account_info_iter)?;
    //         let tokenB_account = token::Account::deserialize(tokenB_info.data)?;
    //         if tokenB_info.key != tokenB_account {
    //             return Err(Error::InvalidTokenBAccount);
    //         }
    //
    //         //input token
    //         let input_token_info = next_account_info(account_info_iter)?;
    //         let input_account = token::Account::deserialize(input.data)?;
    //
    //         //incoming token should be delegated to the TokenSwap intance authority
    //         if input_account.authority != token_authority {
    //             return Err(Error::InvalidTokenAuthority);
    //         }
    //
    //         let output_token_info = next_account_info(account_info_iter)?;
    //         if input_account.token == tokenA_account.token {
    //             let invariant = Invariant { tokenA: tokenA.amount, tokenB: tokenB.amount};
    //             let exchange = invariant.swap(input_account.amount)?;
    //             Self::transfer_token(instance_id, input_account, tokenA_account, input_account.amount)?;
    //             Self::transfer_token(instance_id, tokenB_account, output_token_info.key, exchange)?;
    //         } else {
    //             let invariant = Invariant { tokenA: tokenB.amount, tokenB: tokenA.amount};
    //             let exchange = invariant.swap(input_account.amount)?;
    //             Self::transfer_token(instance_id, input_account, tokenB_account, input_account.amount)?;
    //             Self::transfer_token(instance_id, tokenA_account, output_token_info.key, exchange)?;
    //         }
    //         Ok(())
    //     }
    //
    //     pub fn process_withdraw<I: Iterator<Item = &'a AccountInfo<'a>>>(
    //         program_id: &Pubkey,
    //         amount: u64,
    //         account_info_iter: &mut I,
    //     ) -> ProgramResult {
    //         let token_swap_account = next_account_info(account_info_iter)?;
    //         let state = State::deserialize(&token_swap_account.data.borrow())?;
    //         let swap = state.swap()?;
    //
    //         let authority = next_account_info(account_info_iter)?;
    //         if !authority.is_signer {
    //             return Err(ProgramError::MissingRequiredSignature);
    //         }
    //         if !authority.pubkey != swap.authority {
    //             return Err(ProgramError::InvalidAuthority);
    //         }
    //         let instance_id = token_swap_account.key;
    //         let token_authority = Pubkey::create_program_address(&[instance_id, "authority"], program_id)?;
    //
    //         let token_info = next_account_info(account_info_iter)?;
    //         let tokenA_account = Pubkey::create_program_address(&[instance_id, "tokenA"], program_id)?;
    //         let tokenB_account = Pubkey::create_program_address(&[instance_id, "tokenB"], program_id)?;
    //         let destination = next_account_info(account_info_iter)?;
    //
    //         if token_info.key == tokenA_account {
    //             Self::transfer_token(instance_id, tokenA_account, destination, amount)?;
    //         } else if token_info.key == tokenB_account {
    //             Self::transfer_token(instance_id, tokenB_account, destination, amount)?;
    //         } else {
    //             return Err(Error::InvalidTokenAAccount);
    //         }
    //         Ok(())
    //     }
    //
    //
    //     /// Processes an [Instruction](enum.Instruction.html).
    //     pub fn process(
    //         program_id: &Pubkey,
    //         accounts: &'a [AccountInfo<'a>],
    //         input: &[u8],
    //     ) -> ProgramResult {
    //         let instruction = Instruction::deserialize(input)?;
    //         let account_info_iter = &mut accounts.iter();
    //         match instruction {
    //             Instruction::Init => {
    //                 info!("Instruction: Init");
    //                 Self::process_init(account_info_iter)
    //             },
    //             Instruction::Swap => {
    //                 info!("Instruction: Swap");
    //                 Self::process_swap(program_id, account_info_iter)
    //             },
    //             Instruction::Withdraw => {
    //                 info!("Instruction: Withdraw");
    //                 Self::process_withdraw(program_id, account_info_iter)
    //             }
    //         }
    //     }
}
